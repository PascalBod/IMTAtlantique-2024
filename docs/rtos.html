<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="icon" href="favicon.ico">

    <title>RTOS for ML</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/pb.css">
    <link rel="stylesheet" href="pres-style.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
	
        <!-- -------------------- Contents ---------------------------------------- -->

        <section>
          <h3>Contents</h3>
          <div class="pbcolumns">
            <div class="pbsmaller">
              <ul>
                <li><a href="#/foreword">Foreword</a></li>
                <li><a href="#/rtos">What is an RTOS?</a></li>
                <li><a href="#/benefits">Benefits</a></li>
                <li><a href="#/drawbacks">Drawbacks</a></li>
                <li><a href="#/components">Components</a></li>
                <li><a href="#/tasks">Tasks</a></li>
                <li><b>Practice: tasks</b>
                    <ul>
                        <li><a href="#/practiceStartTask">Creating and starting a task</a></li>
                        <li><a href="#/practiceStart2Tasks">Starting two tasks with bugs</a></li>
                    </ul>
                </li>
                <li><a href="#/concurrencyControl">Concurrency control</a>
                    <ul>
                        <li><a href="#/practiceSharedStructure"><b>Practice: shared structure</b></a></li>
                        <li><a href="#/concurrencyIntro">Introduction</a></li>
                        <li><a href="#/concurrencyMutex">Mutex</a></li>
                        <li><a href="#/practiceSharedStructureMutex"><b>Practice: shared structure with mutex</b></a></li>
                        <li><a href="#/concurrencyPriorityInversion">Priority inversion</a></li>
                        <li><a href="#/concurrencyDeadlock">Deadlock</a></li>
                    </ul>
                </li>
              </ul>
            </div>
            <div class="pbsmaller">
              <ul>
                <li><a>Concurrency - continued</a>
                    <ul>
                        <li><a href="#/concurrencySemaphore">Semaphore</a></li>
                        <li><a href="#/practiceSemaphore01"><b>Practice: semaphore</b></a></li>
                    </ul>
                </li>
                <li><a href="#/communication">Communication</a>
                    <ul>
                        <li><a href="#/communicationIntroduction">Introduction</a></li>
                        <li><a href="#/communicationQueues">Queues</a></li>
                        <li><a href="#/practiceQueueExample">Queue: example</a></li>
                        <li><a href="#/practicePreventingDeadlocks"><b>Practice: preventing deadlocks</b></a></li>
                    </ul>
                </li>
                <li><a href="#/intermediateSummary1">Intermediate summary</a></li>
                <li><a href="#/time">Time</a></li>
                <li><a href="#/memoryAllocation">Memory allocation</a></li>
                <li><a href="#/middleware">Middleware</a></li>
                <li><a href="#/toLearnMore">To learn more</a></li>
              </ul>
            </div>
          </div>
        </section>
        
        <!-- -------------------- Foreword ---------------------------------------- -->
        
        <section id="foreword">
          <h2>Foreword</h2>
        </section>
        <section>
            <h3>Problem</h3>
            <p>The bare metal architecture (ISR + background task) seen before does not provide answers
               to the following questions:</p>
            <ul>
                <li>How to structure application code in several "independent" units of execution?</li>
                <li>How to share data between these units?</li>
                <li>How to handle different priorities?</li>
                <li>How to ensure that time constraints are met (or not met)?</li>
                <li>Etc.</li>
            </ul>
        </section>
        <section>
            <h3>A solution</h3>
            <p>An RTOS.</p>
            <p>The one we'll use as support for the practice session: FreeRTOS as integrated by Espressif in ESP-IDF.</p>
        </section>
        
        <!-- -------------------- What is an RTOS ---------------------------------------- -->
        
        <section id="rtos">
          <h2>What is an RTOS?</h2>
        </section>
        <section>
          <p>Something that provides answers to the previous questions.</p>
        </section>
        <section>
          <h3>More precisely</h3>
          <p class="pbcenter">RTOS = OS intended for real-time applications.</p>
          <ul>
            <li>Provides minimal latency when handling events</li>
            <li>Guarantees predictable response time</li>
          </ul>
        </section>
        <section>
            <h3>Soft and hard real time</h3>
            <ul>
                <li><b>Hard real time</b>: when a system will cease to function if a deadline is missed, 
                    which can result in catastrophic consequences</li>
                <li class="fragment"><b>Soft real time</b>: when a system continues to function even if
                    itâ€™s unable to execute within an allotted time. If the system has missed its deadline,
                    it will not result in critical consequences. The system can continue to function,
                    though with undesirable lower quality of output</li>
            </ul>
            <div class="pbverysmall">Source: <a href="https://www.intel.com/content/www/us/en/robotics/real-time-systems.html" title="Intel" target="_blank">Intel</a></div>
        </section>
        <section>
            <p>This presentation is about soft real time only.</p>
        </section>
        
        <!-- -------------------- Benefits ---------------------------------------- -->
        
        <section id="benefits">
          <h2>Benefits</h2>
        </section>
        <section>
          <ul>
            <li>
              Provides a way to split application code in several execution blocks
            </li>
            <li class="fragment fade-in">
              Allows to prioritize execution blocks
            </li>
            <li class="fragment fade-in">
              Application architecture easier to design: several execution blocks can 
              concurrently process events
            </li>
            <li class="fragment fade-in">
              Can reuse existing middleware (TCP/IP stack, flash file system, time handling, etc.)
              more easily
            </li>
            <li class="fragment fade-in">
              Provides a common reference framework for teams of several developers
            </li>
            <li class="fragment fade-in">
              Makes application code more portable (to different hardware targets)
            </li>
            <li class="fragment fade-in">
              ...
            </li>
          </ul>
        </section>
        
        <!-- -------------------- Drawbacks ---------------------------------------- -->
        
        <section id="drawbacks">
          <h2>Drawbacks</h2>
        </section>
        <section>
          <ul>
            <li>
              Requires more flash memory (from a few KB to a few tens of KB)
            </li>
            <li class="fragment fade-in">
              Requires more RAM (fixed quantity + quantity depending on execution blocks)
            </li>
            <li class="fragment fade-in">
              Consumes some processing power (a few %)
            </li>
            <li class="fragment fade-in">
              Associated learning curve must be taken into account
            </li>
            <li class="fragment fade-in">
              Brings in a software dependency
            </li>
          </ul>
        </section>
        
        <!-- -------------------- Components ---------------------------------------- -->
        
        <section id="components">
          <h2>Components</h2>
        </section>
        <section>
          <p class="pbcenter">Usual components:</p>
          <ul>
            <li>
              Scheduler - assigns computing resource to the execution blocks <em>(tasks</em> or 
              <em>threads)</em>
            </li>
            <li class="fragment fade-in">
              Services allowing concurrent accesses to shared resources
            </li>
            <li class="fragment fade-in">
              Communication services letting tasks exchange data
            </li>
            <li class="fragment fade-in">
              Time services
            </li>
            <li class="fragment fade-in">
              Memory allocation services
            </li>
            <li class="fragment fade-in">
              Middleware: Wi-Fi stack, Bluetooth stack, TCP/IP stack, USB stack, flash file system, 
              GUI, etc.
            </li>
          </ul>
          <p class="pbsmaller fragment fade-in">GUI: Graphical User Interface</p>
        </section>
        
        <!-- -------------------- Tasks ---------------------------------------- -->
        
        <section id="tasks">
          <h2>Tasks</h2>
        </section>
        <section>
          <p>Task: a long-living execution block.</p>
          <ul>
            <li>The application is made of several tasks.</li>
            <li>These tasks may have to exchange data and to synchronize.</li>
            <li>Each task has its own execution context</li>
            <li>Each task can be assigned a priority</li>
            <li>Each task is assigned a "fair" proportion of processing time by the scheduler</li>
          </ul>
        </section>
        <section>
          <p>A task may be in one of several states. Usually:</p>
          <ul>
            <li>Ready: the task is ready to run, but another one is using the processor</li>
            <li>Running: the task is being executed</li>
            <li>Blocked (or Waiting): the task is waiting for an event (timer timeout, reception of
                a byte on a serial link, etc.)</li>
            <li>Suspended: the task won't use the processor anymore</li>
          </ul>
        </section>
        <section>
          <h3>For FreeRTOS:</h3>
          <img src="images/freeRtosTaskStates.gif">
          <div class="pbverysmall">Source: <a href="https://www.freertos.org/RTOS-task-states.html" 
                                              title="FreeRTOS" target="_blank">FreeRTOS</a></div>
        </section>
        <section>
          <h3>For Zephyr OS:</h3>
          <img src="images/zephyrTaskStates.svg">
          <div class="pbverysmall">Source: <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#thread-states" 
                                              title="Zephyr Project" target="_blank">Zephyr Project</a></div>
        </section>
        <section>
          <p>On a microcontroller with one core: only one task can be executed at a given time.</p>
          <p>&rArr; Difference between <em>concurrency</em> and <em>parallelism:</em></p>
          <ul>
            <li><strong>Concurrency</strong>: several tasks appear to be running at the same time</li>
            <li><strong>Parallelism</strong>: several tasks are really running at the same time</li>
          </ul>
        </section>
        <section>
          <p>The scheduler is the magic behind concurrency.</p>
          <p>Scheduling method depends on the RTOS.</p>
          <p>For FreeRTOS:</p>
          <ul>
            <li>
              <strong>Fixed priority</strong> - task priority is not changed (excepted for priority inheritance - see farther)
            </li>
            <li class="fragment fade-in">
              <strong>Preemptive</strong> - if a higher priority task enters ready state (due to 
              some event), and a lower priority task is being executed, the scheduler stops it 
              and starts the higher priority one
            </li>
            <li class="fragment fade-in">
              <strong>Round-robin</strong> - every task in the set of tasks with same priority is
              guaranteed to be executed after some time
            </li>
            <li class="fragment fade-in">
              <strong>Time sliced</strong> - switching between tasks with same priority occurs on a 
              periodic basis, after a fixed time period
            </li>
          </ul>
        </section>
        <section>
          <p>When a task requests to wait for some event:</p>
          <ul>
            <li>The task enters the <em>blocked</em> state</li>
            <li>The scheduler schedules the task with the highest priority, having waited for the longest 
              time period</li>
          </ul>
        </section>
        <section>
          <p>When a task with a given priority loops, for instance polling for an event without 
            waiting for it:</p>
          <ul>
            <li>Tasks with lower priority will never be executed.</li>
          </ul>
        </section>
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>task_handle_t task_create(...)</code></li>
            <li><code>status_t task_delete(task_handle_t th)</code></li>
            <li><code>status_t task_priority_set(task_handle_t th)</code></li>
            <li><code>status_t task_suspend(task_handle_t th)</code></li>
            <li><code>status_t task_resume(task_handle_t th)</code></li>
            <li><code>...</code></li>
          </ul>
        </section>
        
        <!-- -------------------- Practice: creating and starting a task --------------------- -->
        
        <section id="practiceStartTask">
          <h3>Practice: creating and starting a task</h3>
        </section>
        <section>
            <h4>Reference documentation</h4>
            <ul>
                <li><a href="https://docs.espressif.com/projects/esp-idf/en/v5.0.5/esp32/api-reference/system/freertos_idf.html"
                    target="_blank">ESP-IDF FreeRTOS API Reference</a></li>
                <li><a href="https://docs.espressif.com/projects/esp-idf/en/v5.0.5/esp32/api-guides/startup.html"
                    target="_blank">ESP-IDF Application Startup Flow</a></li>
                <li><a href="https://www.freertos.org/features.html" target="_blank">
                    FreeRTOS Kernel Developer Docs</a></li>
                <li><a href="https://www.freertos.org/a00106.html" target="_blank"">FreeRTOS API Reference</a></li>
                <li><a href="https://www.freertos.org/FreeRTOS-Coding-Standard-and-Style-Guide.html#NamingConventions"
                    target="_blank">FreeRTOS Naming Conventions</a></li>
            </ul>
        </section>
        <section>
          <ul>
            <li>Import the <code>10-startTask</code> project from the <code>exercises</code> directory</li>
            <li>Build it, run it, look at the log messages</li>
          </ul>
        </section>
        <section>
            <h4>How to create and start a task:</h4>
            <pre><code data-trim data-noescape data-line-numbers class="codeblock">
    BaseType_t os_rs = xTaskCreatePinnedToCore(
            vTaskCode,          // Task code.
            "OurFirstTask",	    // Task name.
            2048,               // Task stack depth (in bytes).
            NULL,               // Task parameters. Not used here.
            5,                  // Priority.
            NULL,               // Task handle (output). Not used here.
            APP_CPU_NUM         // Run task on APP_CPU.
            );    
            </code></pre>
        </section>
        <section>
            <ul>
                <li>Starts the function passed as argument as a task</li>
                <li>Task name is mainly there for debugging purpose</li>
                <li>Every task is like a separate bare metal application: it needs its own stack</li>
                <li>Stack depth must allow to store task's data and stack. Required size may be checked by program</li>
                <li>Priority is from 0 (lowest) up to 24 (highest priority defined in <code>FreeRTOSConfig.h</code>)</li>
                <li>Task handle argument: if control of the task is required later on</li>
                <li>The ESP32 is dual-core: it's possible to require the task to run on a given core</li>
            </ul>
        </section>
        <section>
            <h4>The task code:</h4>
            <pre><code data-trim data-noescape data-line-numbers class="codeblock">
void vTaskCode(void *pvParameters) {

    while (true) {
        ESP_LOGI(TAG, "Hello from task!");
        vTaskDelay(pdMS_TO_TICKS(TASK_MESSAGE_PERIOD_MS));
    }
    // A task function MUST NOT return.
    
}            
            </code></pre>
        </section>
        <section>
            <ul>
                <li>A task function MUST NOT return</li>
                <li>But it can commit suicide or be killed, with the <code>vTaskDelete</code> function</li>
                <li>ESP-IDF starts a task watchdog: if a task does not call a FreeRTOS function after a while, an
                    interrupt is triggered</li>
                <li>A good practice: event-driven code</li>
            </ul>
        </section>
        <section>
            <h4>Global application startup flow</h4>
            <ul>
                <li>First core (PRO CPU) startup:
                    <ul>
                        <li>First-stage bootloader (ROM): loads second-stage bootloader into RAM</li>
                        <li>Second-stage bootloader: loads partition table, loads application RAM segments,
                            configures the Flash MMU
                        <li>Application startup:
                            <ul>
                                <li>Environment initialization (exceptions, data initialization, clocks, etc.)</li>
                                <li>System initialization (application information log, heap allocator, 
                                    time functions, serial console, security, etc.)</li>
                                <li>Main task creation, scheduler startup, <code>app_main</code> is run</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Second core (APP CPU) startup - similar</li>
            </ul>
            <p><code>app_main</code> is not a normal FreeRTOS task: it may return.</p>
            <p class="pbsmaller">Note: the MMU is not a full MMU.</p>
        </section>

        <section id="practiceStart2Tasks">
          <h3>Practice: starting two tasks with bugs</h3>
        </section>
         
        <section>
          <ul>
            <li>Import the <code>11-start2Tasks</code> project from the <code>exercises</code> directory</li>
            <li>Build, flash, run, check the log messages</li>
            <li>What happens? Why?</li>
            <li>Make <code>app_main</code> wait a bit (3 or 4 s) before returning. What happens? Why?</li>
            <li>So, what's the problem?</li>
          </ul>
        </section>
        <section>
            <p>This example introduces a common source of bugs: asynchronous use of deallocated storage.</p>
            <p>We have two different bugs here:</p>
            <ul>
                <li>The two task creations are done with the same task parameters</li>
                <li>Task parameters storage is deallocated while the tasks still need them</li>
            </ul>
            <p class="fragment">Always think twice before referencing a variable allocated in automatic storage.</p>
        </section>
        
        <!-- -------------------- Concurrency control ---------------------------------------- -->
        
        <section id="concurrencyControl">
          <h2>Concurrency control</h2>
        </section>
        
        <!-- -------------------- Practice: shared structure --------------------------------- -->
        
        <section id="practiceSharedStructure">
            <h3>Practice: shared structure</h3>
        </section>
        <section>
          <ul>
            <li>Import the <code>12-sharedStructure</code> project from the <code>exercises</code> directory</li>
          </ul>
        </section>
        <section>
            <p>What the application does:</p>
            <ul>
                <li>Two tasks are started</li>
                <li>A structure, <code>sharedStruct</code> is shared between the two tasks</li>
                <li>The structure contains two unsigned integers</li>
                <li>Each task assigns the same value (depending on the task) to the two integers</li>
                <li>Delays are inserted, to simulate some processor workload</li>
                <li>The two integers are displayed at the end of each task iteration</li>
            </ul>
            <p>Read the source code, build, flash, and monitor</p>
            <p>What happens? Why?</p>
        </section>
        <section>
            <p>In real life (of an embedded developer), concurrency problems are far less evident than here &#x1F642;</p>
            <p class="fragment">They may occur on shared data, and on shared physical interfaces</p>
        </section>
        <section>
            <p>In next slides, we see how to handle this class of problems.</p>
        </section>
        
        <!-- -------------------- Concurrency - introduction --------------------------------- -->
        
        <section id="concurrencyIntro">
          <h3>Aim of concurrency control</h3>
          <p class="pbcenter">Generate correct results for concurrent operations on same resource.</p>
        </section>
        <section>
          <h3>Shared resources</h3>
          <ul>
            <li>Hardware: interfaces and peripherals</li>
            <li>Data structures used to transfer information between tasks, and between ISRs and tasks</li>
          </ul>
        </section>
        <section>
          <h3>Critical section</h3>
          <ul>
            <li>Part of a program that must be protected from being executed by concurrent tasks</li>
            <li>In other words: it provides atomic access to a shared resource</li>
          </ul>
        </section>
        <section>
          <h3>Simplest implementation</h3>
          <ul>
            <li>For a system with only one processor: disabling/enabling interrupt(s)</li>
          </ul>
          <p>But better to use the RTOS services described in next pages, in any case.</p>
        </section>
        
        <!-- -------------------- Concurrency - mutex --------------------------------- -->
        
        <section id="concurrencyMutex">
          <h3>Mutex (MUTual EXclusion)</h3>
          <ul>
            <li>Guards a resource</li>
            <li>Can be imagined as containing a token</li>
            <li>A task which wants to access a given resource requests the token from the mutex:
              <ul>
                <li>If it is available: OK</li>
                <li>If it is not available: the task stays blocked on the mutex until the 
                  token is available or a timeout occurs</li>
              </ul>
            </li>
            <li>A task which has obtained the token must release it once it stops accessing the resource</li>
          </ul>
        </section>
        <section>
          <p>This is a cooperation agreement. Creating a mutex does not protect a resource from a task that would
            not use the mutex!
          </p>
        </section>
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>mutex_handle_t mutex_create()</code></li>
            <li><code>status_t mutex_acquire(mutex_handle_t mh, timeout_t timeout)</code></li>
            <li><code>status_t mutex_release(mutex_handle_t mh)</code></li>
            <li><code>status_t mutex_delete(mutex_handle_t mh)</code></li>
          </ul>
          <p class="pbcenter">An ISR must not try to take a mutex.</p>
        </section>
        
        <!-- -------------------- Practice: shared structure with mutex -------------------- -->
        
        <section id="practiceSharedStructureMutex">
            <h3>Practice: shared structure with mutex</h3>
        </section>
        <section>
          <ul>
            <li>Import the <code>13-sharedStructMutex</code> project from the <code>exercises</code> directory</li>
            <li>Perform the <code>TODO</code> task</li>
          </ul>
        </section>
        
        <!-- -------------------- Concurrency - priority inversion ------------------------ -->
        
        <section id="concurrencyPriorityInversion">
          <h3>Potential problem</h3>
          <p>Context:</p>
          <ul>
            <li>A task T3, of high priority, shares a resource with T1, a task of low priority</li>
            <li>The resource is protected by a mutex, M</li>
            <li>A task T2, of medium priority, performs some continuous processing, and almost 
              never waits for an event</li>
          </ul>
        </section>
        <section>
          <h4>Successive actions</h4>
          <div class="row">
            <div class="column">
              <div class="r-stack">
                <img src="images/priorityInversion-01.png" 
                     class="fragment fade-in-then-out" data-fragment-index="1">
                <img src="images/priorityInversion-02.png" 
                     class="fragment fade-in-then-out" data-fragment-index="2">
                <img src="images/priorityInversion-03.png" 
                     class="fragment fade-in-then-out" data-fragment-index="3">
                <img src="images/priorityInversion-04.png" 
                     class="fragment fade-in-then-out" data-fragment-index="4">
                <img src="images/priorityInversion-05.png" 
                     class="fragment fade-in-then-out" data-fragment-index="5">
                <img src="images/priorityInversion-06.png" 
                     class="fragment fade-in-then-out" data-fragment-index="6">
                <img src="images/priorityInversion-06.png" 
                     class="fragment fade-in-then-out" data-fragment-index="7">
              </div>
            </div>
            <div class="column">
              <ul class="pbsmaller2">
                <li class="fragment fade-in pbsmaller2" data-fragment-index="1">
                  The highest priority task, T3, is executing. Then it waits for an event.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="2">
                  The medium priority task, T2, can now execute. Then it waits for an event.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="3">
                  The low priority task, T1, can now execute. Then it requests to acquire M,
                  acquires it, and goes on executing.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="4">
                  Event for T2 is received. The scheduler schedules T2.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="5">
                  Event for T3 is received. The scheduler schedules T3. Then T3 requests to acquire M.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="6">
                  But M is held by T1. So T3 enters blocked state. And the scheduler schedules T2.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="7">
                  At T2 almost never waits for an event, T1 will not be able to run again, and
                  won't be able to release M: T3 stays blocked. T2, of lower priority than T3,
                  blocks T3.
                </li>
              </ul>
            </div>
          </div>
        </section>
        <section>
          <h4>Result</h4>
          <ul>
            <li>T2, of lower priority than T3, runs, instead of T3, as if it was of higher priority</li>
            <li>This is the problem of <strong>priority inversion</strong></li>
          </ul>
        </section>
        <section>
          <h4>A (partial) solution</h4>
          <ul>
            <li>
              If a high priority task blocks while attempting to acquire a mutex that is currently held by 
              a lower priority task, then the priority of the task holding the mutex is temporarily 
              raised to that of the blocking task
            </li>
            <li>This is <strong>priority inheritance</strong></li>
            <li>Does not entirely solve the problem. The real solution is a good system design</li>
          </ul>
        </section>
        <section>
          <h4>A real-life example of priority inversion</h4>
          <ul>
            <li>In 1997, Pathfinder landed on Mars</li>
            <li>After some time, the spacecraft began experiencing system resets and loosing sensor data</li>
            <li>A remote (!) debug session found the source of the problem: priority inversion</li>
          </ul>
          <div class="pbverysmall">Source: <a href="http://www.cs.cornell.edu/courses/cs614/1999sp/papers/pathfinder.html" 
                                              title="Mars Pathfinder" target="_blank">Cornell University</a></div>
        </section>
        
        <!-- -------------------- Concurrency - deadlock ------------------------ -->
        
        <section id="concurrencyDeadlock">
          <h4>Another potential problem</h4>
          <p>Context:</p>
          <ul>
            <li>Task T1 would like to acquire a first mutex, MA and then a second one, MB</li>
            <li>Task T2 would like to acquire MB and then MA</li>
          </ul>
        </section>
        <section>
          <h4>Successive actions</h4>
          <div class="row">
            <div class="column">
              <div class="r-stack">
                <img src="images/deadLock-01.png" 
                     class="fragment fade-in-then-out" data-fragment-index="1">
                <img src="images/deadLock-02.png" 
                     class="fragment fade-in-then-out" data-fragment-index="2">
                <img src="images/deadLock-03.png" 
                     class="fragment fade-in-then-out" data-fragment-index="3">
                <img src="images/deadLock-04.png" 
                     class="fragment fade-in-then-out" data-fragment-index="4">
                <img src="images/deadLock-05.png" 
                     class="fragment fade-in-then-out" data-fragment-index="5">
              </div>
            </div>
            <div class="column">
              <ul class="pbsmaller">
                <li class="fragment fade-in pbsmaller" data-fragment-index="1">
                  T1 requests to acquire MA, and acquires it.
                </li>
                <li class="fragment fade-in pbsmaller" data-fragment-index="2">
                  T2 requests to acquire MB, and acquires it.
                </li>
                <li class="fragment fade-in pbsmaller" data-fragment-index="3">
                  T1 requests to acquire MB and stays blocked on it.
                </li>
                <li class="fragment fade-in pbsmaller" data-fragment-index="4">
                  T2 requests to acquire MA and stays blocked on it.
                </li>
                <li class="fragment fade-in pbsmaller" data-fragment-index="5">
                  <strong>Deadlock</strong>!
                </li>
              </ul>
            </div>
          </div>
        </section>
        <section>
          <h4>Solution</h4>
          <p class="pbcenter">A good system design.</p>
          <p class="pbcenter">(See a possible solution farther.)</p>
        </section>
        
        <!-- -------------------- Concurrency - semaphore ------------------------ -->
        
        <section id="concurrencySemaphore">
          <h3>Semaphore</h3>
          <ul>
            <li>Guards a set of resources</li>
            <li>Contains a variable counting the number of free resources</li>
            <li>A task which wants to access one of the resources calls the semaphore <em>take</em>
              function. This decrements the variable</li>
            <li>At the end of the access, <em>give</em> must be called. This increments the variable</li>
          </ul>
        </section>
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>sem_handle_t sem_create(int max_count, int initial_count)</code></li>
            <li><code>status_t sem_take(sem_handle_t sh, timeout_t timeout)</code></li>
            <li><code>status_t sem_give(sem_handle_t sh)</code></li>
            <li><code>status_t sem_delete(sem_handle_t sh)</code></li>
          </ul>
          <p class="pbcenter">An ISR must not try to take a semaphore.</p>
        </section>
        
        <!-- -------------------- Practice: semaphore ------------------------ -->
        
        <section id="practiceSemaphore01">
            <h3>Practice: semaphore</h3>
        </section>
        <section>
          <ul>
            <li>Import the <code>14-semaphore01</code> project from the <code>exercises</code> directory</li>
            <li>Perform the <code>TODO</code> task</li>
          </ul>
        </section>
        
        <!-- -------------------- Concurrency - mutex vs semaphore ------------ -->
        
        <section>
          <h3>Mutex vs semaphore</h3>
          <ul>
            <li>A mutex provides priority inheritance, a semaphore does not</li>
            <li>A mutex can be used recursively by a task</li>
            <li>A mutex must be released by the task which acquired it</li>
            <li>A mutex is used to protect access to something</li>
            <li>A semaphore is used to signal something</li>
          </ul>
        </section>
        
        <!-- -------------------- Communication - introduction ------------ -->
        
        <section id="communicationIntroduction">
          <h2>Communication</h2>
        </section>
        <section>
          <p>By <em>communication</em> we mean:</p>
          <ul>
            <li>Exchanging data between tasks</li>
            <li>Exchanging data between ISRs and tasks</li>
          </ul>
        </section>
        <section>
          <p>Exchanging data is usually asynchronous: data producer may produce data at some time, while 
            data consumer may try to consume data at another time.
          </p>
          <p class="fragment fade-in">
            Data exchange must be protected so that the consumer always gets consistent data.
          </p>
          <p class="fragment fade-in">
            It is good to provide a mechanism letting the consumer know that there is some data to consume.
          </p>
        </section>
        
        <!-- -------------------- Communication - queues ------------ -->
        
        <section id="communicationQueues">
          <h3>Queues</h3>
          <ul>
            <li>Used to send messages between a source and a destination</li>
          </ul>
          <img src="images/queue-01.png">
        </section>
        <section>
          <p>Usually:</p>
          <ul>
            <li>A queue is FIFO (Firt In First Out)</li>
            <li>The write operation returns immediately</li>
            <li>Trying to read from an empty queue blocks</li>
            <li>Trying to write into a full queue blocks or returns an error</li>
            <li>Messages are of fixed size (but may contain pointers)</li>
            <li>Messages are passed by copy (remember the automatic storage bug!)</li>
          </ul>
        </section>
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>queue_handle_t queue_create(int queue_length, int message_size)</code></li>
            <li><code>status_t queue_send(queue_handle_t qh, void *message, timeout_t timeout)</code></li>
            <li><code>status_t queue_receive(queue_handle_t qh, void *message, timeout_t timeout)</code></li>
            <li><code>status_t queue_delete(queue_handle_t qh)</code></li>
          </ul>
        </section>
        
        <!-- -------------------- Practice: queue example ------------ -->
        
        <section id="practiceQueueExample">
            <h3>Practice: queue example</h3>
        </section>
        <section>
          <ul>
            <li>Import the <code>15-queueExample</code> project from the <code>exercises</code> directory</li>
            <li>Read the source code, build, flash, monitor</li>
          </ul>
          <p>Is the value of <code>QUEUE_LENGTH</code> important in this example?</p>
          <p>In which (other) case can it be important?</p>
        </section>
        
        <!-- -------------------- Practice: preventing deadlocks ------------ -->
        
        <section id="practicePreventingDeadlocks">
          <h3>Queues: a good way to prevent deadlocks</h3>
          <ul>
            <li>Do not use critical sections to provide access to shared resources</li>
            <li>Use message queues to implement server tasks providing access to the resources</li>
          </ul>
        </section>
        
        <section>
            <h3>Practice: remove a deadlock using a queue</h3>
        </section>
        <section>
            <ul>
                <li>Import the <code>16-sharedStructures</code> project from the <code>exercises</code> directory</li>
                <li>Read the source code, build, flash, monitor</li>
            </ul>
            <p>In a real application, identifying the origin of a deadlock may be far more difficult than here!</p>
        </section>
        <section>
            <p>Now, that's up to you:</p>
            <ul>
            <li>To remove the deadlock, use a queue instead of mutexes</li>
            </ul>
            <p>Hint: see the slide three slides before this one</p>
        </section>
        
        <!-- -------------------- Intermediate summary 1 ------------ -->
        
        <section id="intermediateSummary1">
            <h3>Intermediate summary</h3>
        </section>
        <section>
            <p>In a concurrent environment, sharing objects in the right way is difficult.</p>
            <p>With a single core, disabling interrupts may be enough.</p>
            <p>In a multicore environment, more sophisticated tools are required.</p>
        </section>
        <section>
            <p>To manage access to a shared object:</p>
            <ul>
                <li>A mutex</li>
                <li class="fragment">...or a semaphore</li>
                <li class="fragment">Must be used with caution!</li>
            </ul>
        </section>
        <section>
            <p>To make a task wait on an event:</p>
            <ul>
                <li>A semaphore</li>
                <li class="fragment">...or a mutex</li>
            </ul>
        </section>
        <section>
            <p>Another technical solution:</p>
            <ul>
                <li>A queue associated to  server</li>
            </ul>
            <p>Can remove many deadlock problems.</p>
        </section>
        <section>
            <p>There are other tools: event flags, etc.</p>
            <p>Check the documentation of your RTOS.</p>
        </section>
        
        
        <section id="time">
          <h2>Time</h2>
        </section>
        <section>
          <h3>Timer</h3>
          <ul>
            <li>Software timers: service provided by the RTOS, based on at least one hardware timer</li>
            <li>No limitation (excepted RAM) on the number of timers</li>
            <li>When the timer reaches its duration, it calls its callback function</li>
            <li>The callback function is passed a parameter that allows to identify the timer</li>
            <li>Do not block in the callback function!</li>
          </ul>
        </section>
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>timer_t timer_create(timer_callback_t function)</code></li>
            <li><code>status_t timer_start(timer_t timer, time_period_t duration)</code></li>
            <li><code>status_t timer_stop(timer_t timer)</code></li>
            <li><code>status_t timer_delete(timer_t timer)</code></li>
          </ul>
        </section>
        <section>
          <h3>Time functions</h3>
          <ul>
            <li>Time is local to the microcontroller</li>
            <li>Function to get current (local) time</li>
            <li>Function to convert time (e.g. POSIX format)</li>
          </ul>
        </section>
        <section id="memoryAllocation">
          <h2>Memory allocation</h2>
        </section>
        <section>
          <h3>Reminder</h3>
          <p>Variables declared in functions are <a href="https://pascalbod.github.io/stm32-dev-en-presentation/#/31"
                                                    target="_blank">allocated on the stack</a>.</p>
          <ul>
            <li>These variables are known as <em>automatic</em></li>
            <li>They don't exist anymore when the function terminates</li>
            <li>(Unless the <code>static</code> storage class is used...)</li>
          </ul>
        </section>
        <section>
          <h3>Automatic variables may not be enough</h3>
          <ul>
            <li>An application may require an amount of memory not known beforehand</li>
            <li>An application may require to allocate some memory to some task, and reallocate it to some other task
              later on</li>
            <li>Some data structures and associated operations may require dynamic memory (linked lists...)</li>
          </ul>
        </section>
        <section>
          <h3>Dynamic memory allocation</h3>
          <ul>
            <li>Memory is allocated when the application requests it</li>
            <li>The application must release memory when no more used</li>
            <li>The memory is allocated from the <em>heap</em></li>
            <li>The standard C library provides <code>malloc()</code> and <code>free()</code> functions</li>
            <li>But usually they can't be used in a concurrent environment</li>
            <li>&rArr; Usually, the RTOS provides its own functions</li>
          </ul>
        </section>
        <section>
          <h3>Drawbacks of dynamic memory allocation</h3>
          <ul>
            <li>
              Several interwoven allocation/release cycles of memory blocks of different sizes may lead
              to heap fragmentation
            </li>
            <li>
              Allocation and release times are not deterministic (but not as bad as garbage collecting
              for higher-level languages)
            </li>
          </ul>
          <p>&rArr; If possible, do not use dynamic memory allocation</p>
        </section>
        <section id="middleware">
          <h2>Middleware</h2>
        </section>
        <section>
          <p>Quite often, developing an application requires more than an RTOS:</p>
          <ul>
            <li>Storing data in flash memory</li>
            <li>Handling integrated radio interfaces (Wi-Fi, Bluetooth...)</li>
            <li>Using one of the IP protocols (TCP, UDP...) over some networking layer</li>
            <li>Using some messaging protocols (MQTT, CoAP...)</li>
            <li>Logging</li>
            <li>Updating the code in the field (FUOTA - Firmware Update Over The Air)</li>
            <li>Artifical Intelligence tooling</li>
            <li>etc.</li>
          </ul>
        </section>
        <section>
          <p>The availability of such middleware components depends on the RTOS.</p>
          <p>Some components may be generic (RTOS independent) but may require some integration.</p>
          <p>&rArr; Check the ecosystem against your needs before choosing an RTOS</p>
        </section>
        <section id="toLearnMore">
          <h2>To learn more</h2>
        </section>
        <section>
          <ul>
            <li><a href="https://www.freertos.org/FreeRTOS-quick-start-guide.html" target="_blank">
                FreeRTOS - Kernel Quick Start Guide</a></li>
            <li><a href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/index.html"
                   target=""_blank>ESP-IDF - Get Started</a></li>
            <li><a href="https://docs.zephyrproject.org/latest/introduction/index.html"
                   target="_blank">Zephyr - Introduction</a></li>
          </ul>
        </section>
	
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
	  hash: true,
	  slideNumber: 'c/t',
	  // Scroll view inhibited until arrow keys can be used.
	  //view: 'scroll',
	  //scrollProgress: true,
	  // Learn about plugins: https://revealjs.com/plugins/
	  plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
      });
    </script>
  </body>
</html>      
